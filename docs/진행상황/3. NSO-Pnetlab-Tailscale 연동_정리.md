# NSO-Pnetlab-Tailscale 연동 가이드

## 개요

본 가이드는 물리적으로 완전히 분리된 두 시스템, **NSO-PC**와 **Pnetlab VM**을 연동하는 방법을 기술합니다.

원활한 Pnetlab 장비관리를 위해서 Pnetlab이 설치된 PC와 admin PC를 별도로 구성하여 프로젝트를 진행했습니다.

---

## I. 문제 제기 및 아키텍처

### 핵심 과제: 네트워크 고립 (Network Isolation)

- **NSO-PC (관리 시스템)**: 네트워크 자동화를 수행하는 NSO Docker 컨테이너가 실행되는 메인 PC
- **Pnetlab VM (가상화 호스트)**: CE01과 같은 가상 라우터가 동작하는 가상화 환경
- **문제점**: Pnetlab VM 내부의 가상 장비들은 `10.10.10.0/24`와 같은 고립된 가상 네트워크에서 동작합니다. NSO-PC는 이 네트워크의 존재 자체를 알지 못하며, 물리적으로 다른 네트워크 대역에 있으므로 `CE01`의 `10.10.10.101` IP로 직접 접근할 수 없습니다.

### 일반적인 해결책과 한계

가장 단순한 방법은 Pnetlab VM의 네트워크를 "브리지 모드"로 설정하여 NSO-PC와 동일한 로컬 `192.168.x.x` 네트워크에 연결하는 것입니다. 하지만 이 방법은 NSO-PC(노트북)를 다른 물리적 위치로 이동시킬 경우, `192.168.x.x` 네트워크가 변경되어 모든 연결이 끊어지는 문제가 있습니다.

### 최종 해결책: Tailscale 서브넷 라우팅

이러한 위치 종속성 문제를 해결하기 위해 **Tailscale**을 사용하여 두 컴퓨터를 위치에 상관없이 항상 연결되는 하나의 가상 사설망(Overlay Network)으로 묶습니다.

하지만 Tailscale만으로는 부족합니다. Tailscale은 `NSO-PC`와 `Pnetlab VM`까지만 1:1로 연결해 줄 뿐, `Pnetlab VM` 안에 존재하는 `10.10.10.x` 네트워크의 존재는 알지 못합니다.

따라서 **Pnetlab VM을 "서브넷 라우터"로 설정**합니다. Pnetlab VM이 Tailscale 네트워크에 "내가 `10.10.10.0/24` 네트워크로 가는 라우팅 경로를 알고 있으니, 이 대역으로 향하는 모든 트래픽은 나에게 보내라"고 광고하도록 설정합니다.

**아키텍처:**

- **NSO-PC**: `100.78.136.89` (Tailscale IP)
- **Pnetlab VM**: `100.66.240.82` (Tailscale IP) / `10.10.10.1` (OOB 게이트웨이 IP)
- **CE01 (가상 장비)**: `10.10.10.101` (OOB 관리 IP)

이 아키텍처를 통해 NSO-PC가 물리적으로 어디에 있든, Pnetlab의 가상 장비에 안정적으로 접속하여 자동화를 수행할 수 있습니다.

---

## II. 사전 준비 사항

본 가이드는 다음 환경이 이미 구축된 상태에서 시작합니다.

1. **Pnetlab**: VM 설치 및 실행 완료, 실험실 로드 완료
2. **NSO-PC**: Docker 설치 완료, NSO 도커 컨테이너(`cisco-nso-dev`) 실행 중
3. **Tailscale**: NSO-PC와 Pnetlab VM에 각각 설치 및 동일 계정으로 인증 완료
4. **네트워크 계획**: Pnetlab 내부 OOB(Out-of-Band) 관리 대역으로 `10.10.10.0/24` 사용

---

## III. 1단계: Pnetlab VM을 "서브넷 라우터"로 만들기

첫 번째는 Pnetlab VM(Ubuntu)이 "서브넷 라우터" 역할을 할 수 있도록 네트워크 설정을 해주는 것입니다. VM이 `10.10.10.x` 대역과 Tailscale 네트워크 간의 트래픽을 중계하도록 설정합니다.

### 1. Pnetlab OOB 인터페이스 확인

Pnetlab 랩의 "Management Cloud" 노드는 Pnetlab VM 내부에 **가상 스위치(브릿지)**를 만듭니다. 우리는 이 스위치의 이름(`pnetX`)을 알아내야 합니다.

Pnetlab VM 터미널에서 `brctl show`를 실행합니다.

**설명**: Pnetlab(EVE-NG 기반)은 가상 장비를 VM 호스트에 연결할 때 `vunl...` (가상 케이블) 인터페이스를 생성하여 `pnetX` (가상 스위치)에 연결합니다.

```bash
root@pnetlab:~# brctl show
bridge name    bridge id        STP enabled    interfaces
...
pnet2          8000.3a79a65c4f14    no         vunl26_0
                                                vunl27_0
                                                ...
```

**결과**: `vunl...` 인터페이스가 다수 연결된 브릿지(이 예제에서는 `pnet2`)가 우리가 사용할 OOB 관리 네트워크용 가상 스위치입니다. 이 이름은 재부팅하거나 랩 구성에 따라 달라질 수 있으므로 항상 확인해야 합니다.

### 2. 게이트웨이 IP 및 포워딩 설정

이제 `pnet2` 스위치에 게이트웨이 IP를 할당하고, VM이 라우터처럼 작동하도록 커널 파라미터를 수정합니다.

#### Pnetlab VM 터미널에서 실행

**1) pnet2 인터페이스 활성화 (재부팅 시 꺼질 수 있음)**

```bash
sudo ip link set pnet2 up
```

**설명**: 재부팅하면 가상 스위치의 전원이 'DOWN' 상태일 수 있으니, 'up' 시켜 활성화합니다.

**2) pnet2 인터페이스에 게이트웨이 IP 할당**

```bash
sudo ip addr add 10.10.10.1/24 dev pnet2
```

**설명**: `pnet2` 스위치(브릿지) 자체에 10.10.10.x 네트워크의 게이트웨이 IP(10.10.10.1)를 할당합니다. Pnetlab 내부의 모든 가상 장비는 나중에 이 `10.10.10.1`을 기본 게이트웨이로 사용하게 됩니다.

⚠️ **주의**: 이 IP는 CE01 등 다른 장비와 절대 중복되면 안 됩니다.

**3) IPv4 포워딩 활성화 (필수!)**

```bash
sudo sysctl -w net.ipv4.ip_forward=1
sudo sysctl -w net.ipv6.conf.all.forward=1
```

**설명**: 가장 중요한 설정입니다. 리눅스 커널에게 "너는 이제부터 라우터다. 한쪽(Tailscale)에서 온 패킷을 다른 쪽(pnet2)으로 포워딩하는 것을 허용한다"고 설정합니다.

#### 영구 설정 (재부팅 후에도 유지)

위 설정들은 **휘발성**이므로 Pnetlab VM을 재부팅하면 초기화됩니다. 영구적으로 설정하려면 다음을 수행합니다.

**IP 포워딩 영구화:**

```bash
sudo nano /etc/sysctl.conf
```

파일에서 `#net.ipv4.ip_forward=1`과 `#net.ipv6.conf.all.forwarding=1` 줄을 찾아서 맨 앞의 `#`을 제거합니다.

**인터페이스 IP 영구화 (Netplan 방식 - Ubuntu 18.04+):**

```bash
sudo nano /etc/netplan/01-netcfg.yaml
```

`pnet2` 인터페이스 설정을 `renderer: networkd` 섹션에 추가합니다.

```yaml
network:
  version: 2
  renderer: networkd
  ethernets:
    # ... (기존 eth0, pnet0 등 설정)
    pnet2:
      dhcp4: no
      dhcp6: no
      addresses:
        - 10.10.10.1/24
```

설정 적용:

```bash
sudo netplan apply
```

---

## IV. 2단계: Pnetlab 가상 장비(CE01) 설정

이제 VM이 준비되었으니, 가상 장비(CE01)가 VM과 통신할 수 있게 설정할 차례입니다.

### 1. Telnet을 이용한 초기 접속 (복붙 활성화)

Pnetlab 웹 콘솔은 복사/붙여넣기가 자주 깨지고 불안정합니다. **Putty**나 **Windows Terminal**의 **Telnet** 기능을 사용하는 것이 훨씬 안정적입니다.

1. Pnetlab 웹 UI에서 `CE01` 장비의 Telnet 포트 확인 (예: `30031`)
2. NSO-PC에서 Pnetlab VM의 **메인 IP**와 해당 포트로 Telnet 접속

```bash
telnet 100.66.240.82 30031
```

### 2. CE01 초기 설정 (SSH 활성화 및 라우팅)

Telnet으로 접속한 `CE01` 콘솔에 아래 설정을 붙여넣습니다. (비밀번호 `123`, ID `admin` 기준)

**설명**: 각 장비마다 수정이 필요한 부분에 `▼▼▼` 표시를 해두었습니다.

```
! 'enable' 모드로 먼저 진입해야 합니다.
enable

! ▼▼▼ 1. 여기에 'enable' 비밀번호를 입력하세요 (예: 123) ▼▼▼
123

! 'configure terminal'로 설정 모드 진입
conf t

! (필수!) 오타를 쳤을 때 멈추는 현상을 방지합니다.
! 설명: Cisco IOS는 'ls' 같은 알 수 없는 명령어를 도메인 이름으로 해석하려 30초간 멈춥니다.
! 이 기능을 꺼서 작업 효율을 높입니다.
no ip domain-lookup

! ▼▼▼ 2. 호스트네임 설정 (장비 구분용) ▼▼▼
hostname CE01

! ▼▼▼ 3. OOB 관리용 인터페이스 설정 (e0/0) ▼▼▼
interface Ethernet0/0

! ▼▼▼ 4. 이 장비의 고유 OOB IP (예: 10.10.10.101) ▼▼▼
ip address 10.10.10.101 255.255.255.0
no shutdown
exit

! 5. (매우 중요) '기본 경로(Default Route)' 설정
! 설명: CE01이 NSO-PC(100.x.x.x)로 응답을 보낼 '출구'를 알려줍니다.
! "모든 트래픽은 게이트웨이(Pnetlab VM의 10.10.10.1)에게 보내라"는 뜻입니다.
! 이 10.10.10.1 IP는 III-2 단계에서 설정한 VM의 IP와 반드시 일치해야 합니다.
ip route 0.0.0.0 0.0.0.0 10.10.10.1

! 6. SSH 활성화 세트
ip domain-name mylab.local

! SSH를 켜기 위한 암호화 키 생성
crypto key generate rsa general-keys modulus 1024

! ▼▼▼ 7. NSO가 접속할 관리자 계정 생성 ▼▼▼
username admin privilege 15 secret 123

! Telnet은 끄고 SSH 접속만 허용
line vty 0 4
transport input ssh
login local
exit
end

! 8. (필수!) 재부팅해도 날아가지 않게 저장
write memory
```

---

## V. 3단계: Tailscale 서브넷 라우팅 설정

지금까지 Pnetlab VM과 CE01은 `10.10.10.x` 네트워크 안에서 서로 대화할 수 있게 되었습니다. 이제 이 네트워크를 Tailscale 세상에 "광고"할 차례입니다.

### 1. Pnetlab VM 터미널에서 라우트 광고 명령 실행

**설명**: 이 명령어는 Pnetlab VM이 Tailscale 네트워크에 "내가 `10.10.10.0/24`로 가는 길을 아니까, 그쪽으로 갈 트래픽은 나에게 보내!"라고 외치는 과정입니다.

```bash
sudo tailscale up --advertise-routes=10.10.10.0/24
```

### 2. Tailscale Admin Console (웹)에 접속

- [Machines] 탭에서 `pnetlab` VM을 찾아 [Edit route settings...]를 클릭합니다.
- `10.10.10.0/24` 경로를 **[Approve]** (승인)합니다.

**설명**: 보안을 위해, Tailscale 관리자가 웹에서 이 '광고'를 승인해줘야만 실제 경로가 열립니다. 이 승인 없이는 아무도 이 경로를 이용할 수 없습니다.

---

## VI. 4단계: 연결 검증 (총 3단계)

모든 설정 완료 후, NSO-PC에서 `CE01`까지 길이 뚫렸는지 확인합니다.

### 1. Pnetlab VM -> CE01 (내부 확인)

```bash
ping 10.10.10.101
```

### 2. CE01 -> Pnetlab VM (내부 확인)

```bash
ping 10.10.10.1
```

### 3. NSO-PC -> CE01 (최종 확인)

```bash
ping 10.10.10.101
```

### 4. NSO-PC -> CE01 (SSH 테스트)

**설명**: `ping`(ICMP)이 성공해도 SSH(TCP)는 실패할 수 있습니다. `CE01`(오래된 장비)과 `NSO-PC`(최신 PC)가 서로 사용하는 **암호화 방식이 맞지 않아서** 협상 오류가 발생하기 때문입니다.

아래는 우리가 찾아낸 "옛날 방식도 허용하는" 완전한 SSH 접속 명령어입니다.

```bash
ssh -o KexAlgorithms=+diffie-hellman-group14-sha1 \
    -o Ciphers=+aes256-cbc \
    -o HostKeyAlgorithms=+ssh-rsa \
    -o MACs=+hmac-sha1,hmac-sha1-96 \
    admin@10.10.10.101
```

**오류 해결:**

- `WARNING: REMOTE HOST...CHANGED!`: CE01의 키를 다시 생성하면 PC가 "지문이 바뀌었다"고 경고합니다.

```bash
ssh-keygen -R 10.10.10.101
```

명령으로 PC에 저장된 옛날 키를 삭제 후 재시도합니다.

- `Connection timed out`: Tailscale 연결이 일시적으로 불안정하거나, `CE01`의 22번 포트가 막힌 것입니다.

```bash
Test-NetConnection 10.10.10.101 -Port 22
```

(PowerShell)로 포트가 열렸는지 확인합니다.

---

## VII. 5단계: NSO 장비 등록 (최종)

모든 길이 열렸으니, 드디어 NSO에 `CE01` 장비를 공식 등록합니다.

### 1. NSO CLI 접속 (C-style)

NSO-PC 터미널에서 다음 명령어로 NSO CLI에 접속합니다.

```bash
docker exec -it cisco-nso-dev bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && ncs_cli -C -u admin"
```

**설명**: 이 명령어는 `cisco-nso-dev` 도커 컨테이너에 `bash`로 접속한 뒤, NSO 환경 파일(`ncsrc`)을 로드하고, `admin` 계정으로 **C-style CLI**(`-C` 옵션)에 접속하는 모든 과정을 한 줄로 처리합니다.

### 2. Authgroup 생성 (L2VPN)

**설명**: NSO에 장비의 ID/PW를 직접 입력하는 대신, `admin/123` 정보가 담긴 `L2VPN`이라는 인증 프로필(Authgroup)을 만듭니다. 나중에 100대 장비가 생겨도 이 프로필만 참조하면 됩니다. `L2VPN`이라는 이름은 원하는 대로 변경 가능합니다.

```
! (C-style 프롬프트 admin@ncs# 에서 실행)
config
devices authgroups group L2VPN

! ▼▼▼ IV-2 단계에서 설정한 ID/PW와 일치해야 함 ▼▼▼
default-map remote-name admin remote-password 123
commit
exit
```

### 3. 장비 등록 (초기화 및 재등록)

**설명**: `sync-from` 실패로 NSO의 장치 상태가 "꼬이는"(stuck) 경우가 많습니다. 가장 확실한 방법은 기존에 실패했던 장치 설정을 깨끗하게 삭제하고, 우리가 알아낸 모든 SSH 알고리즘 설정을 포함하여 완전한 상태로 다시 등록하는 것입니다.

```
config

! 1. (필수) 기존에 꼬인 CE01 설정이 있다면 삭제
no devices device CE01
commit

! 2. CE01 장비 재등록 (모든 설정 포함)
devices device CE01

! ▼▼▼ IV-2 단계에서 설정한 IP와 일치 ▼▼▼
address 10.10.10.101
port 22

! ▼▼▼ VII-2 단계에서 만든 "인증 프로필" 이름 ▼▼▼
authgroup L2VPN

! ▼▼▼ 설치된 NED 드라이버 이름 (show packages로 확인) ▼▼▼
device-type cli ned-id cisco-ios-cli-6.110
state admin-state unlocked

! 3. (필수) SSH 협상 오류 해결을 위한 알고리즘 4종 세트
! 설명: NSO가 오래된 CE01 장비와 '옛날 암호화 방식'으로
! 통신할 수 있도록 허용해주는 설정입니다.
! (NSO 버전과 NED에 따라 public-key 또는 server-host-key를 사용)

! Host Key (SSH-RSA)
ssh-algorithms public-key ssh-rsa

! Cipher (암호화)
ssh-algorithms cipher aes256-cbc

! Kex (키 교환)
ssh-algorithms kex diffie-hellman-group14-sha1

! MAC (인증)
ssh-algorithms mac hmac-sha1

commit
exit
```

### 4. 호스트 키(SSH Fingerprint) 가져오기

**설명**: 마지막 관문입니다. NSO는 `CE01`의 "지문(Host Key)"을 모릅니다. 이 명령은 NSO가 `CE01`에 접속해 지문을 가져와서 신뢰할 수 있는 장치로 등록하는 과정입니다.

```
! (admin@ncs# 프롬프트에서 실행)
devices device CE01 ssh fetch-host-keys
```

**결과**: `result updated` 또는 `result new` (성공적으로 지문을 가져왔다는 뜻)

### 5. 최종 동기화

**설명**: 드디어! NSO가 `CE01`에 접속하여 `show running-config`를 실행하고, 모든 설정을 NSO 데이터베이스로 가져옵니다.

```
devices device CE01 sync-from
```

**최종 결과**: `result true` (이 메시지가 나오면 연동이 완벽하게 성공한 것입니다.)

---

## VIII. 추가: 대량 등록을 위한 자동화 스크립트

매번 장비를 타이핑으로 등록하는 것은 비효율적입니다. 다음은 `CE02`, `CE03`... 등을 등록할 때 사용하는 자동화 스크립트입니다.

### 장비 설정

IV. 2단계의 Telnet/Putty 복붙을 사용하여 `CE02`(10.10.10.102), `CE03`(10.10.10.103) 등의 초기 설정을 완료합니다. (IP와 hostname만 변경)

### NSO 등록 자동화

아래 파이썬 스크립트(`add_devices.py`)를 NSO 서버에서 실행하면, 장비 목록을 NSO에 자동으로 등록, SSH 설정, 키 동기화, `sync-from`까지 한 번에 처리할 수 있습니다.

**파일**: `add_devices.py` (NSO-PC)

**수정할 곳**: 이 스크립트를 사용하기 전에 `devices_list`와 `DEVICE_AUTHGROUP`, `DEVICE_NED_ID`를 사용자 환경에 맞게 수정해야 합니다.

NSO-PC 아무 곳에서 `python add_devices.py`를 실행하면 자동으로 컨테이너에 접속하여 명령어를 수행합니다.

```python
import subprocess
import sys

# ▼▼▼ 1. 여기에 등록할 장비 목록 (이름, IP)을 수정하세요 ▼▼▼
devices_list = [
    ("CE02", "10.10.10.102"),
    # ("CE03", "10.10.10.103"),
    # ("CE04", "10.10.10.104"),
    # ("P01", "10.10.10.2"),
    # ("PE02", "10.10.10.3"),
]

DEVICE_PORT = 22
DEVICE_AUTHGROUP = "L2VPN"
DEVICE_NED_ID = "cisco-ios-cli-6.110"

def run_cli_command(cmd_input):
    """NSO CLI 명령어 실행 헬퍼 함수 - Docker 컨테이너 내에서 실행"""
    full_cmd = f'docker exec cisco-nso-dev bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && echo \\"{cmd_input}\\" | ncs_cli -C -u admin"'
    result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
    return result

def setup_devices():
    print("--- NSO 장비 자동 등록 스크립트 시작 ---")
    
    # --- 1단계: NSO CLI를 사용한 장비 설정 추가 ---
    print(f"1. NSO에 {len(devices_list)}개 장비 설정 중...")
    for name, ip in devices_list:
        print(f"\n [장비 등록] {name} ({ip})")
        
        # 기본 설정 - 각 명령어를 개별적으로 실행
        print(f" 기본 설정 중...")
        config_cmds = [
            f"config",
            f"devices device {name} address {ip}",
            f"devices device {name} port {DEVICE_PORT}",
            f"devices device {name} authgroup {DEVICE_AUTHGROUP}",
            f"devices device {name} device-type cli ned-id {DEVICE_NED_ID}",
            f"devices device {name} state admin-state unlocked",
            f"commit",
            f"exit"
        ]
        for cmd in config_cmds:
            result = run_cli_command(cmd)
            if result.returncode != 0 and "Commit complete" not in result.stdout:
                if "syntax error" not in result.stderr and "error" not in result.stderr.lower():
                    print(f" {cmd}: 성공")
        
        # SSH 알고리즘 설정 - cipher, kex, mac, public-key
        print(f" SSH 알고리즘 설정 중...")
        ssh_cmds = [
            f"config",
            f"devices device {name}",
            f"ssh-algorithms cipher aes128-cbc",
            f"ssh-algorithms cipher 3des-cbc",
            f"ssh-algorithms cipher aes256-cbc",
            f"ssh-algorithms kex diffie-hellman-group14-sha1",
            f"ssh-algorithms mac hmac-sha1",
            f"ssh-algorithms public-key ssh-rsa",
            f"commit",
            f"exit"
        ]
        for cmd in ssh_cmds:
            result = run_cli_command(cmd)
            if "Commit complete" in result.stdout:
                print(f" SSH 알고리즘 설정 완료: 성공")
                break
    
    print("\n--- 2단계: SSH 키 가져오기 및 동기화 ---")
    for name, ip in devices_list:
        print(f"\n--- {name} ({ip}) 처리 중 ---")
        
        # 1) SSH 호스트 키 가져오기
        print(f" [SSH 키] 호스트 키 가져오는 중...")
        result = run_cli_command(f"devices device {name} ssh fetch-host-keys")
        if "result updated" in result.stdout or "result true" in result.stdout:
            print(f" SSH 호스트 키 가져오기 성공")
        else:
            print(f" SSH 호스트 키 오류: {result.stdout.strip()}")
        
        # 2) 장비 설정 동기화
        print(f" [동기화] 장비 설정 동기화 중...")
        result = run_cli_command(f"devices device {name} sync-from")
        if "result true" in result.stdout:
            print(f" 장비 동기화 성공!")
        else:
            print(f" 장비 동기화 오류: {result.stdout.strip()}")
    
    print("\n--- 모든 장비 등록 완료 ---")

if __name__ == '__main__':
    setup_devices()
```

---

## 참고자료

- Excalidraw 아키텍처 다이어그램: https://excalidraw.com/
- NSO 공식 문서
- Tailscale 서브넷 라우팅 가이드
