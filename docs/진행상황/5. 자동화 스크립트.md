이 문서는 PnetLab 환경에서 네트워크 장비의 SSH 활성화부터 Batfish용 설정 파일 생성까지의 전체 자동화 프로세스를 설명한다. 각 단계별 스크립트와 명령어들을 포함하며, 현재 프로젝트의 파일 구조와 설정에 맞게 업데이트되었다.

프로젝트의 핵심 목표는 네트워크 구성 검증을 위한 Q&A 데이터셋 생성으로, L1-L5 난이도 레벨 체계를 기반으로 한 메트릭 기반 질문 생성을 지원한다.

## 프로젝트 구조

```
Make_Dataset/
├── src/
│   ├── Automate_Setup.py          # 장비 SSH 활성화 자동화 (telnetlib3 기반)
│   ├── main.py                     # 데이터셋 생성 메인 스크립트
│   └── core/
│       ├── builder_core.py         # 메트릭 계산 및 질문 생성 로직
│       └── rule_based_generator.py # 정책 기반 질문 템플릿 생성
├── policies.json                   # L1-L5 레벨별 메트릭 정책 정의
├── requirements.txt                # 프로젝트 의존성 패키지 목록
└── docs/                           # 문서화 파일들
```

## 사전 준비

1. **NSO Docker 컨테이너 실행**
   ```bash
   # NSO 개발 환경 컨테이너 실행
   docker run -d --name cisco-nso-dev -p 8080:8080 cisco-nso-dev:latest
   ```

2. **PnetLab 실험실 구동**
   - 원하는 네트워크 토폴로지 구성
   - 장비별 고유 IP 주소 할당 (예: 10.10.10.101, 10.10.10.102 등)

3. **네트워크 연결 설정**
   - PnetLab VM의 관리 인터페이스 IP 확인 (예: 10.10.10.1)
   - 호스트 PC와 PnetLab 간 네트워크 연결 확인

## 전체 자동화 과정

### 1단계: 장비 SSH 활성화
**파일**: `Make_Dataset/src/Automate_Setup.py`
- Telnet을 통해 장비에 접속하여 SSH 활성화
- 기본 설정 및 관리 계정 생성
- 여러 장비에 대한 배치 처리 지원

### 2단계: NSO 장비 등록
**파일**: `NSO_Add_Device.py`
- NSO에 장비 자동 등록 및 SSH 키 교환
- 장비별 인증 그룹 및 NED ID 설정

### 3단계: 설정 파일 추출
**파일**: `Config_Export_Batfish.py`
- NSO에서 장비 설정을 Batfish 호환 형식으로 추출
- 자동 폴더 구조 생성 및 파일 저장

### 4단계: 데이터셋 생성
**파일**: `Make_Dataset/src/main.py`
- L1-L5 레벨별 메트릭 기반 질문 생성
- L1 랜덤 샘플링 및 L3 비교 질문 지원



## 스크립트 및 명령어 상세 설명

> **중요**: 모든 스크립트는 프로젝트 루트 디렉토리에서 실행해야 한다. 각 스크립트의 설정 값들은 실제 환경에 맞게 수정해야 한다.

### 1. 장비 활성화 자동화 스크립트

**파일 경로**: `Make_Dataset/src/1-Automate_Setup.py`

이 스크립트는 Telnet을 통해 Cisco IOS 장비에 접속하여 SSH를 활성화하고 기본 설정을 수행한다. Python 3.11+에서 deprecated된 `telnetlib` 대신 `telnetlib3`을 사용하여 asyncio 기반으로 구현되었다.

**설정 파일 구조** (`Data/Pnetlab/L2VPN/device_info.json`):
```json
{
  "global_settings": {
    "pnetlab_vm_ip": "192.168.56.101",
    "gateway_ip": "10.10.10.1",
    "domain_name": "mylab.local",
    "enable_password": "123",
    "admin_password": "123"
  },
  "devices": [
    {
      "name": "CE01",
      "oob_ip": "10.10.10.101",
      "telnet_port": 5001
    },
    {
      "name": "PE01",
      "oob_ip": "10.10.10.102",
      "telnet_port": 5002
    }
  ]
}
```

**실행 방법**:
```bash
cd Make_Dataset/src
python 1-Automate_Setup.py
```

**주요 기능**:
- JSON 기반 설정 파일 로드
- 여러 장비에 대한 배치 SSH 활성화
- Cisco IOS 기본 설정 자동 적용
- Telnet 연결 상태 모니터링 및 에러 처리

### 1.1 의존성 패키지 설치

**파일 경로**: `Make_Dataset/requirements.txt`

스크립트 실행 전에 필요한 Python 패키지들을 설치해야 한다:

```bash
cd Make_Dataset
pip install -r requirements.txt
```

**주요 패키지**:
- `telnetlib3`: Telnet 클라이언트 (asyncio 기반)
- `pybatfish`: 네트워크 검증 및 분석
- `pydantic`: 데이터 검증
- 기타 데이터 처리 및 LLM 관련 패키지들


```shell
! 'enable' 모드로 먼저 진입해야 합니다.
enable

! ▼▼▼ 1. 여기에 'enable' 비밀번호를 입력하세요 (예: 123) ▼▼▼
123

! 'configure terminal'로 설정 모드 진입
conf t

! (필수!) 오타를 쳤을 때 멈추는 현상을 방지합니다.
! 설명: Cisco IOS는 'ls' 같은 알 수 없는 명령어를 도메인 이름으로 해석하려 30초간 멈춥니다.
! 이 기능을 꺼서 작업 효율을 높입니다.
no ip domain-lookup

! ▼▼▼ 2. 호스트네임 설정 (장비 구분용) ▼▼▼
hostname CE01

! ▼▼▼ 3. OOB 관리용 인터페이스 설정 (e0/0) ▼▼▼
interface Ethernet0/0

! ▼▼▼ 4. 이 장비의 고유 OOB IP (예: 10.10.10.101) ▼▼▼
ip address 10.10.10.101 255.255.255.0
no shutdown
exit

! 5. (매우 중요) '기본 경로(Default Route)' 설정
! 설명: CE01이 NSO-PC(100.x.x.x)로 응답을 보낼 '출구'를 알려줍니다.
! "모든 트래픽은 게이트웨이(Pnetlab VM의 10.10.10.1)에게 보내라"는 뜻입니다.
! 이 10.10.10.1 IP는 III-2 단계에서 설정한 VM의 IP와 반드시 일치해야 합니다.
ip route 0.0.0.0 0.0.0.0 10.10.10.1

! 6. SSH 활성화 세트
ip domain-name mylab.local

! SSH를 켜기 위한 암호화 키 생성
crypto key generate rsa general-keys modulus 1024

! ▼▼▼ 7. NSO가 접속할 관리자 계정 생성 ▼▼▼
username admin privilege 15 secret 123

! Telnet은 끄고 SSH 접속만 허용
line vty 0 4
transport input ssh
login local
exit
end

! 8. (필수!) 재부팅해도 날아가지 않게 저장
write memory


```

### 2. NSO 장비 등록 스크립트

**파일 경로**: `NSO_Add_Device.py` (프로젝트 루트에 위치)

이 스크립트는 Cisco NSO(네트워크 서비스 오케스트레이터)에 장비를 자동으로 등록하고 SSH 키 교환 및 동기화를 수행한다.

```python

import subprocess
import sys

# ▼▼▼ 1. 여기에 등록할 장비 목록 (이름, IP)을 수정하세요 ▼▼▼
devices_list = [
    ("CE02", "10.10.10.102"),
    # ("CE03", "10.10.10.103"),
    # ("CE04", "10.10.10.104"),
    # ("P01", "10.10.10.2"),
    # ("PE02", "10.10.10.3"),
]
DEVICE_PORT = 22
DEVICE_AUTHGROUP = "L2VPN"
DEVICE_NED_ID = "cisco-ios-cli-6.110"



def run_cli_command(cmd_input):
    """NSO CLI 명령어 실행 헬퍼 함수 - Docker 컨테이너 내에서 실행"""
    full_cmd = f'docker exec cisco-nso-dev bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && echo \\"{cmd_input}\\" | ncs_cli -C -u admin"'
    result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
    return result

def setup_devices():
    print("--- NSO 장비 자동 등록 스크립트 시작 ---")

    # --- 1단계: NSO CLI를 사용한 장비 설정 추가 ---
    print(f"1. NSO에 {len(devices_list)}개 장비 설정 중...")

    for name, ip in devices_list:
        print(f"\n  [장비 등록] {name} ({ip})")

        # 기본 설정 - 각 명령어를 개별적으로 실행
        print(f"    기본 설정 중...")
        config_cmds = [
            f"config",
            f"devices device {name} address {ip}",
            f"devices device {name} port {DEVICE_PORT}",
            f"devices device {name} authgroup {DEVICE_AUTHGROUP}",
            f"devices device {name} device-type cli ned-id {DEVICE_NED_ID}",
            f"devices device {name} state admin-state unlocked",
            f"commit",
            f"exit"
        ]
        
        for cmd in config_cmds:
            result = run_cli_command(cmd)
            if result.returncode != 0 and "Commit complete" not in result.stdout:
                if "syntax error" not in result.stderr and "error" not in result.stderr.lower():
                    print(f"      {cmd}: 성공")

        # SSH 알고리즘 설정 - cipher, kex, mac, public-key
        print(f"    SSH 알고리즘 설정 중...")
        ssh_cmds = [
            f"config",
            f"devices device {name}",
            f"ssh-algorithms cipher aes128-cbc",
            f"ssh-algorithms cipher 3des-cbc",
            f"ssh-algorithms cipher aes256-cbc",
            f"ssh-algorithms kex diffie-hellman-group14-sha1",
            f"ssh-algorithms mac hmac-sha1",
            f"ssh-algorithms public-key ssh-rsa",
            f"commit",
            f"exit"
        ]
        
        for cmd in ssh_cmds:
            result = run_cli_command(cmd)
            if "Commit complete" in result.stdout:
                print(f"      SSH 알고리즘 설정 완료: 성공")
                break

    print("\n--- 2단계: SSH 키 가져오기 및 동기화 ---")
    for name, ip in devices_list:
        print(f"\n--- {name} ({ip}) 처리 중 ---")

        # 1) SSH 호스트 키 가져오기
        print(f"  [SSH 키] 호스트 키 가져오는 중...")
        result = run_cli_command(f"devices device {name} ssh fetch-host-keys")
        if "result updated" in result.stdout or "result true" in result.stdout:
            print(f"    SSH 호스트 키 가져오기 성공")
        else:
            print(f"    SSH 호스트 키 오류: {result.stdout.strip()}")

        # 2) 장비 설정 동기화
        print(f"  [동기화] 장비 설정 동기화 중...")
        result = run_cli_command(f"devices device {name} sync-from")
        if "result true" in result.stdout:
            print(f"    장비 동기화 성공!")
        else:
            print(f"    장비 동기화 오류: {result.stdout.strip()}")

    print("\n--- 모든 장비 등록 완료 ---")

if __name__ == '__main__':
    setup_devices()
    print("\n--- 모든 장비 등록 완료 ---")
```


### 3. Batfish 설정 파일 추출 스크립트

**파일 경로**: `Config_Export_Batfish.py` (프로젝트 루트에 위치)

```python

import subprocess
import sys
import os
import datetime

# ==========================================
# ▼▼▼ 사용자 설정 (여기를 수정하세요) ▼▼▼
# ==========================================

# 1. NSO 도커 컨테이너 이름
CONTAINER_NAME = "cisco-nso-dev"

# 2. 추출된 설정을 저장할 내 PC의 경로 (절대 경로 또는 상대 경로)
# 예: "./batfish_lab1" 또는 "C:/Users/Yujin/Desktop/batfish_snapshots/lab1"
OUTPUT_DIR = "./pnetlab_snapshot"

# 3. 추출할 장비 목록 (비워두면 NSO에 등록된 '모든' 장비를 자동으로 찾습니다!)
# 특정 장비만 뽑고 싶으면 ["CE01", "CE02"] 처럼 채우세요.
TARGET_DEVICES = [] 

# ==========================================

def run_nso_cmd(cmd_input):
    """
    NSO CLI 명령어를 Docker 컨테이너 내부에서 실행하고 결과를 반환하는 함수
    (사용자가 제공한 add_devices.py 로직 활용)
    """
    full_cmd = f'docker exec {CONTAINER_NAME} bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && echo \\"{cmd_input}\\" | ncs_cli -C -u admin"'
    try:
        # encoding='utf-8' 추가하여 한글/특수문자 깨짐 방지
        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True, encoding='utf-8')
        return result.stdout
    except Exception as e:
        print(f"[Error] Docker 명령어 실행 실패: {e}")
        sys.exit(1)

def get_all_devices():
    """NSO에 등록된 모든 장비 이름을 동적으로 가져옵니다."""
    print("NSO에서 장비 목록을 조회 중...")
    # 'show devices list' 명령어로 장비 목록 확인
    output = run_nso_cmd("show devices list")
    
    devices = []
    lines = output.splitlines()
    for line in lines:
        # NSO 출력 파싱 (간단한 공백 기준 분리)
        parts = line.split()
        # 보통 출력 형식이 "NAME ADDRESS ..." 형태임. 헤더나 빈 줄 제외하고 이름 추출
        if len(parts) >= 2 and parts[0] not in ["NAME", "admin@ncs#", "System"]:
             # 간단한 유효성 검사: 이름에 특수문자가 별로 없는지 등 (상황에 따라 조정 가능)
             if not parts[0].startswith("-"): 
                devices.append(parts[0])
    
    # 중복 제거 및 정렬
    return sorted(list(set(devices)))

def clean_config(raw_config):
    """
    NSO live-status에서 가져온 실제 장비 설정을 Batfish 형식으로 정제합니다.
    NSO CLI 프롬프트와 명령어 출력을 제거하고 순수한 Cisco IOS 설정만 남깁니다.
    """
    lines = raw_config.splitlines()
    cleaned_lines = []
    skip_until_config = True

    for line in lines:
        # NSO CLI 프롬프트 및 명령어 라인 건너뛰기
        if "admin@ncs#" in line or "admin@ncs%" in line:
            continue
        
        # live-status exec 명령어 관련 출력 건너뛰기
        if "live-status exec" in line or "devices device" in line:
            continue
            
        # "result" 키워드 (NSO 출력 형식) 건너뛰기
        if line.strip().startswith("result"):
            skip_until_config = False
            continue
        
        # 장비 프롬프트 (CE01#, CE02# 등) 건너뛰기
        if line.strip().endswith("#") and len(line.strip().split()) == 1:
            continue
        
        # 설정 시작 전까지 빈 줄 무시
        if skip_until_config and not line.strip():
            continue
        
        # 실제 설정 내용 시작 (!, version, Building configuration 등)
        if line.strip() and (line.startswith("!") or "version" in line or "Building configuration" in line or "Current configuration" in line):
            skip_until_config = False
        
        if not skip_until_config:
            cleaned_lines.append(line)

    return "\n".join(cleaned_lines)

def main():
    print(f"--- Batfish용 설정 추출 시작 ---")
    
    # 1. 저장할 디렉토리 구조 생성 (configs 폴더가 필수!)
    configs_dir = os.path.join(OUTPUT_DIR, "configs")
    if not os.path.exists(configs_dir):
        try:
            os.makedirs(configs_dir)
            print(f"[Init] 폴더 생성 완료: {configs_dir}")
        except OSError as e:
            print(f"[Error] 폴더 생성 실패: {e}")
            sys.exit(1)
    else:
        print(f"[Init] 저장 경로 확인: {configs_dir}")

    # 2. 장비 목록 확보
    if TARGET_DEVICES:
        device_list = TARGET_DEVICES
        print(f"[Info] 지정된 {len(device_list)}개 장비를 추출합니다.")
    else:
        device_list = get_all_devices()
        print(f"[Info] NSO에서 {len(device_list)}개 장비를 발견했습니다: {device_list}")

    if not device_list:
        print("[Warning] 추출할 장비가 없습니다. NSO 연결 상태를 확인하세요.")
        return

    # 3. 각 장비 설정 추출 및 저장
    success_count = 0
    for device in device_list:
        print(f"\n[Processing] {device} 설정 다운로드 중...")
        
        # NSO live-status exec 명령어로 실제 장비의 running-config 가져오기
        # 이 명령어는 장비에 직접 'show running-config'를 실행하여 순수한 Cisco IOS 설정을 반환합니다
        cmd = f"devices device {device} live-status exec show running-config"
        raw_output = run_nso_cmd(cmd)
        
        if "syntax error" in raw_output or "Error" in raw_output:
             print(f"  -> [Fail] NSO에서 설정을 가져오지 못했습니다.")
             continue

        # 결과 정제
        final_config = clean_config(raw_output)
        
        # 파일 저장 (Batfish는 .cfg 확장자를 좋아합니다)
        file_path = os.path.join(configs_dir, f"{device}.cfg")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(final_config)
            print(f"  -> [Success] 저장 완료: {file_path}")
            success_count += 1
        except IOError as e:
             print(f"  -> [Fail] 파일 쓰기 실패: {e}")

    print(f"\n--- 작업 완료 ---")
    print(f"총 {len(device_list)}개 중 {success_count}개 파일 추출 성공")
    print(f"Batfish 분석 시 '{OUTPUT_DIR}' 폴더를 스냅샷으로 지정하세요.")

if __name__ == "__main__":
    main()


### 4. 데이터셋 생성 메인 스크립트

**파일 경로**: `Make_Dataset/src/main.py`

이 스크립트는 Batfish에서 추출한 네트워크 설정을 기반으로 L1-L5 난이도 레벨별 Q&A 데이터셋을 생성한다.

**실행 방법**:
```bash
cd Make_Dataset/src
python main.py --xml-dir ../data/raw/XML_Data --output-dir ../data/processed
```

**주요 CLI 옵션들**:

| 옵션 | 설명 | 기본값 | 예시 |
|------|------|--------|------|
| `--xml-dir` | XML 설정 파일 디렉토리 | 필수 | `../data/raw/XML_Data` |
| `--output-dir` | 출력 디렉토리 | 필수 | `../data/processed` |
| `--categories` | 생성할 카테고리 목록 | 모든 카테고리 | `System_Inventory,BGP_Consistency` |
| `--l1-sample-ratio` | L1 메트릭 샘플링 비율 (0.0-1.0) | 0.3 | `0.5` |
| `--seed` | 랜덤 시드 (재현성 보장) | 42 | `12345` |
| `--verbose` | 상세 출력 모드 | False | (플래그 옵션) |

**샘플링 전략**:
- **L1 메트릭**: 모든 장비가 아닌 대표 장비만 선택 (기본 30%)
- **L2-L3 메트릭**: 글로벌/AS/VRF/Device_Pair 범위에서 생성
- **L4-L5 메트릭**: Batfish 기반 도달성 및 What-If 분석 (향후 구현 예정)

**출력 파일 구조**:
```
data/processed/
├── questions.csv    # 생성된 질문들
├── answers.json     # 정답 데이터
└── metadata.json    # 생성 통계 및 메타데이터
```

**L1-L5 레벨 체계**:

| 레벨 | 난이도 | 엔진 | 설명 |
|------|--------|------|------|
| L1 | ⭐ | JSON 파싱 | 단일 장비 설정 조회 |
| L2 | ⭐⭐ | JSON 파싱 | 복수 장비 집계 |
| L3 | ⭐⭐⭐ | JSON 파싱 | 계산/비교 분석 |
| L4 | ⭐⭐⭐⭐ | Batfish | 네트워크 도달성 |
| L5 | ⭐⭐⭐⭐⭐ | Batfish | What-If 시뮬레이션 |

## 전체 프로세스 요약

### 단계별 실행 순서

1. **환경 준비**
   ```bash
   # NSO Docker 실행
   docker run -d --name cisco-nso-dev -p 8080:8080 cisco-nso-dev:latest

   # PnetLab 토폴로지 구성 및 장비 시작
   ```

2. **장비 SSH 활성화**
   ```bash
   cd Make_Dataset/src
   pip install -r ../requirements.txt
   python 1-Automate_Setup.py
   ```

3. **NSO 장비 등록**
   ```bash
   python ../../NSO_Add_Device.py
   ```

4. **설정 파일 추출**
   ```bash
   python ../../Config_Export_Batfish.py
   ```

5. **데이터셋 생성**
   ```bash
   python main.py --xml-dir ../data/raw/XML_Data \
                  --output-dir ../data/processed \
                  --l1-sample-ratio 0.3 \
                  --seed 42
   ```

### 주요 설정 파일들

| 파일 | 용도 | 형식 |
|------|------|------|
| `device_info.json` | 장비 연결 정보 | JSON |
| `policies.json` | L1-L5 메트릭 정책 | JSON |
| `requirements.txt` | Python 의존성 | 텍스트 |
| `pnetlab_snapshot/configs/*.cfg` | Batfish 설정 파일 | Cisco IOS |

### 주의사항

- 모든 스크립트는 **프로젝트 루트 디렉토리**에서 실행하는 것을 권장
- PnetLab VM의 IP 주소와 네트워크 설정을 정확히 확인
- NSO Docker 컨테이너가 정상 실행 중인지 확인
- 대량의 장비를 처리할 경우 타임아웃 설정 조정
- 생성된 데이터셋의 품질 검증을 위해 샘플 질문 확인

### 문제 해결

**Telnet 연결 실패 시**:
- PnetLab VM이 실행 중인지 확인
- 장비의 Telnet 포트가 올바른지 확인
- 방화벽 설정 확인

**NSO 등록 실패 시**:
- Docker 컨테이너 상태 확인: `docker ps`
- NSO CLI 접속 테스트: `docker exec -it cisco-nso-dev ncs_cli -C -u admin`

**데이터셋 생성 실패 시**:
- XML 파일 경로 및 형식 확인
- 메트릭 정책 파일(`policies.json`) 무결성 확인
- Python 의존성 패키지 설치 상태 확인

이 자동화 프로세스를 통해 네트워크 구성 검증을 위한 고품질 Q&A 데이터셋을 효율적으로 생성할 수 있다.



