지금까지의 과정을 보면 Pnetlab의 장비마다 접속해서 SSH를 활성화하고 NSO에 등록하고 설정을 추출해야 했습니다. 하지만 이 작업은 단순 반복이기 때문에 최대한 스크립트로 대체하려고 합니다. 이전에 글에서 소개한 명령어와 스크립트들을 모두 정리하려고 합니다.

  
이 글에서는 Pnetlab 장비의 SSH 활성화 부터 Batfish 입력을 위한 설정파일 준비까지 진행합니다.

## 사전 준비
- `NSO-docker` run
- Pnetlab 실험실 구동
- 1-2-3-4 단계 적용

## 과정

1. Putty - Telnet으로 장비 접속
2. `장비활성화` 명령어 붙혀넣기
3. `NSO_Add_Device.py` 스크립트에 장비명과 IP넣고 실행하기
4. `Config_Export_Batfish.py` 실행 -> NSO에 저장된 장비설정을 Batfish 규격에 맞게 자동 추출 스크립트



>[!info] 
> 각 장비명, IP, 폴더경로는 적절하게 수정해야합니다.
## 스크립트 & 명령어

### 1. `장비활성화` 명령어


```shell
! 'enable' 모드로 먼저 진입해야 합니다.
enable

! ▼▼▼ 1. 여기에 'enable' 비밀번호를 입력하세요 (예: 123) ▼▼▼
123

! 'configure terminal'로 설정 모드 진입
conf t

! (필수!) 오타를 쳤을 때 멈추는 현상을 방지합니다.
! 설명: Cisco IOS는 'ls' 같은 알 수 없는 명령어를 도메인 이름으로 해석하려 30초간 멈춥니다.
! 이 기능을 꺼서 작업 효율을 높입니다.
no ip domain-lookup

! ▼▼▼ 2. 호스트네임 설정 (장비 구분용) ▼▼▼
hostname CE01

! ▼▼▼ 3. OOB 관리용 인터페이스 설정 (e0/0) ▼▼▼
interface Ethernet0/0

! ▼▼▼ 4. 이 장비의 고유 OOB IP (예: 10.10.10.101) ▼▼▼
ip address 10.10.10.101 255.255.255.0
no shutdown
exit

! 5. (매우 중요) '기본 경로(Default Route)' 설정
! 설명: CE01이 NSO-PC(100.x.x.x)로 응답을 보낼 '출구'를 알려줍니다.
! "모든 트래픽은 게이트웨이(Pnetlab VM의 10.10.10.1)에게 보내라"는 뜻입니다.
! 이 10.10.10.1 IP는 III-2 단계에서 설정한 VM의 IP와 반드시 일치해야 합니다.
ip route 0.0.0.0 0.0.0.0 10.10.10.1

! 6. SSH 활성화 세트
ip domain-name mylab.local

! SSH를 켜기 위한 암호화 키 생성
crypto key generate rsa general-keys modulus 1024

! ▼▼▼ 7. NSO가 접속할 관리자 계정 생성 ▼▼▼
username admin privilege 15 secret 123

! Telnet은 끄고 SSH 접속만 허용
line vty 0 4
transport input ssh
login local
exit
end

! 8. (필수!) 재부팅해도 날아가지 않게 저장
write memory


```

### 2. `NSO_Add_Device.py` 스크립트

```python

import subprocess
import sys

# ▼▼▼ 1. 여기에 등록할 장비 목록 (이름, IP)을 수정하세요 ▼▼▼
devices_list = [
    ("CE02", "10.10.10.102"),
    # ("CE03", "10.10.10.103"),
    # ("CE04", "10.10.10.104"),
    # ("P01", "10.10.10.2"),
    # ("PE02", "10.10.10.3"),
]
DEVICE_PORT = 22
DEVICE_AUTHGROUP = "L2VPN"
DEVICE_NED_ID = "cisco-ios-cli-6.110"



def run_cli_command(cmd_input):
    """NSO CLI 명령어 실행 헬퍼 함수 - Docker 컨테이너 내에서 실행"""
    full_cmd = f'docker exec cisco-nso-dev bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && echo \\"{cmd_input}\\" | ncs_cli -C -u admin"'
    result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
    return result

def setup_devices():
    print("--- NSO 장비 자동 등록 스크립트 시작 ---")

    # --- 1단계: NSO CLI를 사용한 장비 설정 추가 ---
    print(f"1. NSO에 {len(devices_list)}개 장비 설정 중...")

    for name, ip in devices_list:
        print(f"\n  [장비 등록] {name} ({ip})")

        # 기본 설정 - 각 명령어를 개별적으로 실행
        print(f"    기본 설정 중...")
        config_cmds = [
            f"config",
            f"devices device {name} address {ip}",
            f"devices device {name} port {DEVICE_PORT}",
            f"devices device {name} authgroup {DEVICE_AUTHGROUP}",
            f"devices device {name} device-type cli ned-id {DEVICE_NED_ID}",
            f"devices device {name} state admin-state unlocked",
            f"commit",
            f"exit"
        ]
        
        for cmd in config_cmds:
            result = run_cli_command(cmd)
            if result.returncode != 0 and "Commit complete" not in result.stdout:
                if "syntax error" not in result.stderr and "error" not in result.stderr.lower():
                    print(f"      {cmd}: 성공")

        # SSH 알고리즘 설정 - cipher, kex, mac, public-key
        print(f"    SSH 알고리즘 설정 중...")
        ssh_cmds = [
            f"config",
            f"devices device {name}",
            f"ssh-algorithms cipher aes128-cbc",
            f"ssh-algorithms cipher 3des-cbc",
            f"ssh-algorithms cipher aes256-cbc",
            f"ssh-algorithms kex diffie-hellman-group14-sha1",
            f"ssh-algorithms mac hmac-sha1",
            f"ssh-algorithms public-key ssh-rsa",
            f"commit",
            f"exit"
        ]
        
        for cmd in ssh_cmds:
            result = run_cli_command(cmd)
            if "Commit complete" in result.stdout:
                print(f"      SSH 알고리즘 설정 완료: 성공")
                break

    print("\n--- 2단계: SSH 키 가져오기 및 동기화 ---")
    for name, ip in devices_list:
        print(f"\n--- {name} ({ip}) 처리 중 ---")

        # 1) SSH 호스트 키 가져오기
        print(f"  [SSH 키] 호스트 키 가져오는 중...")
        result = run_cli_command(f"devices device {name} ssh fetch-host-keys")
        if "result updated" in result.stdout or "result true" in result.stdout:
            print(f"    SSH 호스트 키 가져오기 성공")
        else:
            print(f"    SSH 호스트 키 오류: {result.stdout.strip()}")

        # 2) 장비 설정 동기화
        print(f"  [동기화] 장비 설정 동기화 중...")
        result = run_cli_command(f"devices device {name} sync-from")
        if "result true" in result.stdout:
            print(f"    장비 동기화 성공!")
        else:
            print(f"    장비 동기화 오류: {result.stdout.strip()}")

    print("\n--- 모든 장비 등록 완료 ---")

if __name__ == '__main__':
    setup_devices()
    print("\n--- 모든 장비 등록 완료 ---")
```


### 3. `Config_Export_Batfish.py`

```python

import subprocess
import sys
import os
import datetime

# ==========================================
# ▼▼▼ 사용자 설정 (여기를 수정하세요) ▼▼▼
# ==========================================

# 1. NSO 도커 컨테이너 이름
CONTAINER_NAME = "cisco-nso-dev"

# 2. 추출된 설정을 저장할 내 PC의 경로 (절대 경로 또는 상대 경로)
# 예: "./batfish_lab1" 또는 "C:/Users/Yujin/Desktop/batfish_snapshots/lab1"
OUTPUT_DIR = "./pnetlab_snapshot"

# 3. 추출할 장비 목록 (비워두면 NSO에 등록된 '모든' 장비를 자동으로 찾습니다!)
# 특정 장비만 뽑고 싶으면 ["CE01", "CE02"] 처럼 채우세요.
TARGET_DEVICES = [] 

# ==========================================

def run_nso_cmd(cmd_input):
    """
    NSO CLI 명령어를 Docker 컨테이너 내부에서 실행하고 결과를 반환하는 함수
    (사용자가 제공한 add_devices.py 로직 활용)
    """
    full_cmd = f'docker exec {CONTAINER_NAME} bash -c "cd ~/ncs-instance && source ~/nso-6.6/ncsrc && echo \\"{cmd_input}\\" | ncs_cli -C -u admin"'
    try:
        # encoding='utf-8' 추가하여 한글/특수문자 깨짐 방지
        result = subprocess.run(full_cmd, shell=True, capture_output=True, text=True, encoding='utf-8')
        return result.stdout
    except Exception as e:
        print(f"[Error] Docker 명령어 실행 실패: {e}")
        sys.exit(1)

def get_all_devices():
    """NSO에 등록된 모든 장비 이름을 동적으로 가져옵니다."""
    print("NSO에서 장비 목록을 조회 중...")
    # 'show devices list' 명령어로 장비 목록 확인
    output = run_nso_cmd("show devices list")
    
    devices = []
    lines = output.splitlines()
    for line in lines:
        # NSO 출력 파싱 (간단한 공백 기준 분리)
        parts = line.split()
        # 보통 출력 형식이 "NAME ADDRESS ..." 형태임. 헤더나 빈 줄 제외하고 이름 추출
        if len(parts) >= 2 and parts[0] not in ["NAME", "admin@ncs#", "System"]:
             # 간단한 유효성 검사: 이름에 특수문자가 별로 없는지 등 (상황에 따라 조정 가능)
             if not parts[0].startswith("-"): 
                devices.append(parts[0])
    
    # 중복 제거 및 정렬
    return sorted(list(set(devices)))

def clean_config(raw_config):
    """
    NSO live-status에서 가져온 실제 장비 설정을 Batfish 형식으로 정제합니다.
    NSO CLI 프롬프트와 명령어 출력을 제거하고 순수한 Cisco IOS 설정만 남깁니다.
    """
    lines = raw_config.splitlines()
    cleaned_lines = []
    skip_until_config = True

    for line in lines:
        # NSO CLI 프롬프트 및 명령어 라인 건너뛰기
        if "admin@ncs#" in line or "admin@ncs%" in line:
            continue
        
        # live-status exec 명령어 관련 출력 건너뛰기
        if "live-status exec" in line or "devices device" in line:
            continue
            
        # "result" 키워드 (NSO 출력 형식) 건너뛰기
        if line.strip().startswith("result"):
            skip_until_config = False
            continue
        
        # 장비 프롬프트 (CE01#, CE02# 등) 건너뛰기
        if line.strip().endswith("#") and len(line.strip().split()) == 1:
            continue
        
        # 설정 시작 전까지 빈 줄 무시
        if skip_until_config and not line.strip():
            continue
        
        # 실제 설정 내용 시작 (!, version, Building configuration 등)
        if line.strip() and (line.startswith("!") or "version" in line or "Building configuration" in line or "Current configuration" in line):
            skip_until_config = False
        
        if not skip_until_config:
            cleaned_lines.append(line)

    return "\n".join(cleaned_lines)

def main():
    print(f"--- Batfish용 설정 추출 시작 ---")
    
    # 1. 저장할 디렉토리 구조 생성 (configs 폴더가 필수!)
    configs_dir = os.path.join(OUTPUT_DIR, "configs")
    if not os.path.exists(configs_dir):
        try:
            os.makedirs(configs_dir)
            print(f"[Init] 폴더 생성 완료: {configs_dir}")
        except OSError as e:
            print(f"[Error] 폴더 생성 실패: {e}")
            sys.exit(1)
    else:
        print(f"[Init] 저장 경로 확인: {configs_dir}")

    # 2. 장비 목록 확보
    if TARGET_DEVICES:
        device_list = TARGET_DEVICES
        print(f"[Info] 지정된 {len(device_list)}개 장비를 추출합니다.")
    else:
        device_list = get_all_devices()
        print(f"[Info] NSO에서 {len(device_list)}개 장비를 발견했습니다: {device_list}")

    if not device_list:
        print("[Warning] 추출할 장비가 없습니다. NSO 연결 상태를 확인하세요.")
        return

    # 3. 각 장비 설정 추출 및 저장
    success_count = 0
    for device in device_list:
        print(f"\n[Processing] {device} 설정 다운로드 중...")
        
        # NSO live-status exec 명령어로 실제 장비의 running-config 가져오기
        # 이 명령어는 장비에 직접 'show running-config'를 실행하여 순수한 Cisco IOS 설정을 반환합니다
        cmd = f"devices device {device} live-status exec show running-config"
        raw_output = run_nso_cmd(cmd)
        
        if "syntax error" in raw_output or "Error" in raw_output:
             print(f"  -> [Fail] NSO에서 설정을 가져오지 못했습니다.")
             continue

        # 결과 정제
        final_config = clean_config(raw_output)
        
        # 파일 저장 (Batfish는 .cfg 확장자를 좋아합니다)
        file_path = os.path.join(configs_dir, f"{device}.cfg")
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(final_config)
            print(f"  -> [Success] 저장 완료: {file_path}")
            success_count += 1
        except IOError as e:
             print(f"  -> [Fail] 파일 쓰기 실패: {e}")

    print(f"\n--- 작업 완료 ---")
    print(f"총 {len(device_list)}개 중 {success_count}개 파일 추출 성공")
    print(f"Batfish 분석 시 '{OUTPUT_DIR}' 폴더를 스냅샷으로 지정하세요.")

if __name__ == "__main__":
    main()
    
```

